{"ast":null,"code":"import { getMinPointsDelta, getActualDesiredIntervalsCount, setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/double-range';\nimport { withIn, logBase } from '../../common/utils/helper';\nimport { isNullOrUndefined, extend, getValue } from '@syncfusion/ej2-base';\n/**\n * Numeric module is used to render numeric axis.\n */\n\nvar Double = function () {\n  /**\n   * Constructor for the dateTime module.\n   *\n   * @private\n   */\n  function Double(chart) {\n    this.isColumn = 0;\n    this.chart = chart;\n  }\n  /**\n   * Numeric Nice Interval for the axis.\n   *\n   * @private\n   */\n\n\n  Double.prototype.calculateNumericNiceInterval = function (axis, delta, size) {\n    var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);\n    var niceInterval = delta / actualDesiredIntervalsCount;\n\n    if (!isNullOrUndefined(axis.desiredIntervals)) {\n      return niceInterval;\n    }\n\n    var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));\n\n    for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {\n      var interval = _a[_i];\n      var currentInterval = minInterval * interval;\n\n      if (actualDesiredIntervalsCount < delta / currentInterval) {\n        break;\n      }\n\n      niceInterval = currentInterval;\n    }\n\n    return niceInterval;\n  };\n  /**\n   * Actual Range for the axis.\n   *\n   * @private\n   */\n\n\n  Double.prototype.getActualRange = function (axis, size) {\n    this.initializeDoubleRange(axis);\n\n    if (!axis.startFromZero && this.isColumn > 0) {\n      axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n      axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;\n\n      if (axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0) {\n        axis.actualRange.min = 0;\n      } else {\n        axis.actualRange.min = axis.doubleRange.start - axis.actualRange.interval;\n      }\n    } else {\n      axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n      axis.actualRange.min = axis.doubleRange.start;\n      axis.actualRange.max = axis.doubleRange.end;\n    }\n  };\n  /**\n   * Range for the axis.\n   *\n   * @private\n   */\n\n\n  Double.prototype.initializeDoubleRange = function (axis) {\n    //Axis Min\n    if (axis.minimum !== null) {\n      this.min = axis.minimum;\n    } else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n      this.min = 0;\n    } // Axis Max\n\n\n    if (axis.maximum !== null) {\n      this.max = axis.maximum;\n    } else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n      this.max = 5;\n    }\n\n    if (this.min === this.max) {\n      this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;\n    }\n\n    axis.doubleRange = new DoubleRange(this.min, this.max);\n    axis.actualRange = {};\n  };\n  /**\n   * The function to calculate the range and labels for the axis.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  Double.prototype.calculateRangeAndInterval = function (size, axis) {\n    this.calculateRange(axis);\n    this.getActualRange(axis, size);\n    this.applyRangePadding(axis, size);\n    this.calculateVisibleLabels(axis, this.chart);\n  };\n  /**\n   * Calculate Range for the axis.\n   *\n   * @private\n   */\n\n\n  Double.prototype.calculateRange = function (axis) {\n    /*! Generate axis range */\n    this.min = null;\n    this.max = null;\n\n    if (!setRange(axis)) {\n      for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n        var series = _a[_i];\n\n        if (!series.visible) {\n          continue;\n        }\n\n        this.paddingInterval = 0;\n        axis.maxPointLength = series.points.length;\n\n        if ((series.type.indexOf('Column') > -1 || series.type.indexOf('Histogram') > -1) && axis.orientation === 'Horizontal' || series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical') {\n          if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime') && series.xAxis.rangePadding === 'Auto') {\n            this.paddingInterval = getMinPointsDelta(series.xAxis, axis.series) * 0.5;\n          }\n        } //For xRange\n\n\n        if (axis.orientation === 'Horizontal') {\n          if (this.chart.requireInvertedAxis) {\n            this.yAxisRange(axis, series);\n          } else {\n            this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n          }\n        } // For yRange\n\n\n        if (axis.orientation === 'Vertical') {\n          this.isColumn += series.type === 'Column' || series.type === 'Bar' || series.drawType === 'Column' ? 1 : 0;\n\n          if (this.chart.requireInvertedAxis) {\n            this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n          } else {\n            this.yAxisRange(axis, series);\n          }\n        }\n      }\n    }\n  };\n\n  Double.prototype.yAxisRange = function (axis, series) {\n    if (series.dragSettings.enable && this.chart.dragY) {\n      if (this.chart.dragY >= axis.visibleRange.max) {\n        series.yMax = this.chart.dragY + axis.visibleRange.interval;\n      }\n\n      if (this.chart.dragY <= axis.visibleRange.min) {\n        series.yMin = this.chart.dragY - axis.visibleRange.interval;\n      }\n    }\n\n    this.findMinMax(series.yMin, series.yMax);\n  };\n\n  Double.prototype.findMinMax = function (min, max) {\n    if (this.min === null || this.min > min) {\n      this.min = min;\n    }\n\n    if (this.max === null || this.max < max) {\n      this.max = max;\n    }\n\n    if (this.max === this.min && this.max < 0 && this.min < 0) {\n      // max == min\n      this.max = 0;\n    }\n  };\n  /**\n   * Apply padding for the range.\n   *\n   * @private\n   */\n\n\n  Double.prototype.applyRangePadding = function (axis, size) {\n    var start = axis.actualRange.min;\n    var end = axis.actualRange.max;\n\n    if (!setRange(axis)) {\n      var interval = axis.actualRange.interval;\n      var padding = axis.getRangePadding(this.chart);\n\n      if (padding === 'Additional' || padding === 'Round') {\n        this.findAdditional(axis, start, end, interval);\n      } else if (padding === 'Normal') {\n        this.findNormal(axis, start, end, interval, size);\n      } else {\n        this.updateActualRange(axis, start, end, interval);\n      }\n    }\n\n    axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n    this.calculateVisibleRange(size, axis);\n  };\n\n  Double.prototype.updateActualRange = function (axis, minimum, maximum, interval) {\n    axis.actualRange = {\n      min: axis.minimum != null ? axis.minimum : minimum,\n      max: axis.maximum != null ? axis.maximum : maximum,\n      interval: axis.interval != null ? axis.interval : interval,\n      delta: axis.actualRange.delta\n    };\n  };\n\n  Double.prototype.findAdditional = function (axis, start, end, interval) {\n    var minimum;\n    var maximum;\n    minimum = Math.floor(start / interval) * interval;\n    maximum = Math.ceil(end / interval) * interval;\n\n    if (axis.rangePadding === 'Additional') {\n      minimum -= interval;\n      maximum += interval;\n    }\n\n    this.updateActualRange(axis, minimum, maximum, interval);\n  };\n\n  Double.prototype.findNormal = function (axis, start, end, interval, size) {\n    var remaining;\n    var minimum;\n    var maximum;\n    var startValue = start;\n\n    if (start < 0) {\n      startValue = 0;\n      minimum = start + start * 0.05;\n      remaining = interval + minimum % interval;\n\n      if (0.365 * interval >= remaining) {\n        minimum -= interval;\n      }\n\n      if (minimum % interval < 0) {\n        minimum = minimum - interval - minimum % interval;\n      }\n    } else {\n      minimum = start < 5.0 / 6.0 * end ? 0 : start - (end - start) * 0.5;\n\n      if (minimum % interval > 0) {\n        minimum -= minimum % interval;\n      }\n    }\n\n    maximum = end > 0 ? end + (end - startValue) * 0.05 : end - (end - startValue) * 0.05;\n    remaining = interval - maximum % interval;\n\n    if (0.365 * interval >= remaining) {\n      maximum += interval;\n    }\n\n    if (maximum % interval > 0) {\n      maximum = maximum + interval - maximum % interval;\n    }\n\n    axis.doubleRange = new DoubleRange(minimum, maximum);\n\n    if (minimum === 0) {\n      interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n      maximum = Math.ceil(maximum / interval) * interval;\n    }\n\n    this.updateActualRange(axis, minimum, maximum, interval);\n  };\n  /**\n   * Calculate visible range for axis.\n   *\n   * @private\n   */\n\n\n  Double.prototype.calculateVisibleRange = function (size, axis) {\n    axis.visibleRange = {\n      max: axis.actualRange.max,\n      min: axis.actualRange.min,\n      delta: axis.actualRange.delta,\n      interval: axis.actualRange.interval\n    };\n\n    if (this.chart.chartAreaType === 'Cartesian') {\n      var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;\n\n      if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {\n        axis.calculateVisibleRangeOnZooming(this.chart);\n        axis.calculateAxisRange(size, this.chart);\n        axis.visibleRange.interval = axis.enableAutoIntervalOnZooming && axis.valueType !== 'Category' ? this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size) : axis.visibleRange.interval;\n      }\n    }\n\n    axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n  };\n  /**\n   * Calculate label for the axis.\n   *\n   * @private\n   */\n\n\n  Double.prototype.calculateVisibleLabels = function (axis, chart) {\n    /*! Generate axis labels */\n    axis.visibleLabels = [];\n    var tempInterval = axis.visibleRange.min;\n    var labelStyle;\n    var controlName = chart.getModuleName();\n    var isPolarRadar = controlName === 'chart' && chart.chartAreaType === 'PolarRadar';\n\n    if (!isPolarRadar && (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval)) {\n      tempInterval = axis.visibleRange.min - axis.visibleRange.min % axis.visibleRange.interval;\n    }\n\n    var format = this.getFormat(axis);\n    var isCustom = format.match('{value}') !== null;\n    var intervalDigits = 0;\n    var formatDigits = 0;\n\n    if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {\n      formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);\n    }\n\n    axis.format = chart.intl.getNumberFormat({\n      format: isCustom ? '' : format,\n      useGrouping: chart.useGroupingSeparator\n    });\n    axis.startLabel = axis.format(axis.visibleRange.min);\n    axis.endLabel = axis.format(axis.visibleRange.max);\n\n    if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {\n      intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;\n    }\n\n    var duplicateTempInterval;\n\n    for (; tempInterval <= axis.visibleRange.max && duplicateTempInterval !== tempInterval; tempInterval += axis.visibleRange.interval) {\n      duplicateTempInterval = tempInterval;\n      labelStyle = extend({}, getValue('properties', axis.labelStyle), null, true);\n\n      if (withIn(tempInterval, axis.visibleRange)) {\n        triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n      }\n    }\n\n    if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {\n      tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ? +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;\n\n      if (tempInterval <= axis.visibleRange.max) {\n        triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n      }\n    }\n\n    if (axis.getMaxLabelWidth) {\n      axis.getMaxLabelWidth(this.chart);\n    }\n  };\n  /**\n   * Format of the axis label.\n   *\n   * @private\n   */\n\n\n  Double.prototype.getFormat = function (axis) {\n    if (axis.labelFormat) {\n      if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {\n        return '{value}%';\n      }\n\n      return axis.labelFormat;\n    }\n\n    return axis.isStack100 ? '{value}%' : '';\n  };\n  /**\n   * Formatted the axis label.\n   *\n   * @private\n   */\n\n\n  Double.prototype.formatValue = function (axis, isCustom, format, tempInterval) {\n    return isCustom ? format.replace('{value}', axis.format(tempInterval)) : axis.format(tempInterval);\n  };\n\n  return Double;\n}();\n\nexport { Double };","map":{"version":3,"sources":["/workspace/Commb-olap-poc/commb-olap-js/node_modules/@syncfusion/ej2-charts/src/chart/axis/double-axis.js"],"names":["getMinPointsDelta","getActualDesiredIntervalsCount","setRange","triggerLabelRender","DoubleRange","withIn","logBase","isNullOrUndefined","extend","getValue","Double","chart","isColumn","prototype","calculateNumericNiceInterval","axis","delta","size","actualDesiredIntervalsCount","niceInterval","desiredIntervals","minInterval","Math","pow","floor","_i","_a","intervalDivs","length","interval","currentInterval","getActualRange","initializeDoubleRange","startFromZero","actualRange","doubleRange","max","end","start","min","minimum","Number","POSITIVE_INFINITY","maximum","NEGATIVE_INFINITY","valueType","indexOf","calculateRangeAndInterval","calculateRange","applyRangePadding","calculateVisibleLabels","series","visible","paddingInterval","maxPointLength","points","type","orientation","xAxis","rangePadding","requireInvertedAxis","yAxisRange","findMinMax","xMin","xMax","drawType","dragSettings","enable","dragY","visibleRange","yMax","yMin","padding","getRangePadding","findAdditional","findNormal","updateActualRange","calculateVisibleRange","ceil","remaining","startValue","chartAreaType","isLazyLoad","zoomingScrollBar","zoomFactor","zoomPosition","calculateVisibleRangeOnZooming","calculateAxisRange","enableAutoIntervalOnZooming","triggerRangeRender","visibleLabels","tempInterval","labelStyle","controlName","getModuleName","isPolarRadar","format","getFormat","isCustom","match","intervalDigits","formatDigits","labelFormat","parseInt","substring","intl","getNumberFormat","useGrouping","useGroupingSeparator","startLabel","endLabel","split","duplicateTempInterval","formatValue","toFixed","getMaxLabelWidth","isStack100","replace"],"mappings":"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","sourcesContent":["import { getMinPointsDelta, getActualDesiredIntervalsCount, setRange, triggerLabelRender } from '../../common/utils/helper';\nimport { DoubleRange } from '../utils/double-range';\nimport { withIn, logBase } from '../../common/utils/helper';\nimport { isNullOrUndefined, extend, getValue } from '@syncfusion/ej2-base';\n/**\n * Numeric module is used to render numeric axis.\n */\nvar Double = /** @class */ (function () {\n    /**\n     * Constructor for the dateTime module.\n     *\n     * @private\n     */\n    function Double(chart) {\n        this.isColumn = 0;\n        this.chart = chart;\n    }\n    /**\n     * Numeric Nice Interval for the axis.\n     *\n     * @private\n     */\n    Double.prototype.calculateNumericNiceInterval = function (axis, delta, size) {\n        var actualDesiredIntervalsCount = getActualDesiredIntervalsCount(size, axis);\n        var niceInterval = delta / actualDesiredIntervalsCount;\n        if (!isNullOrUndefined(axis.desiredIntervals)) {\n            return niceInterval;\n        }\n        var minInterval = Math.pow(10, Math.floor(logBase(niceInterval, 10)));\n        for (var _i = 0, _a = axis.intervalDivs; _i < _a.length; _i++) {\n            var interval = _a[_i];\n            var currentInterval = minInterval * interval;\n            if (actualDesiredIntervalsCount < (delta / currentInterval)) {\n                break;\n            }\n            niceInterval = currentInterval;\n        }\n        return niceInterval;\n    };\n    /**\n     * Actual Range for the axis.\n     *\n     * @private\n     */\n    Double.prototype.getActualRange = function (axis, size) {\n        this.initializeDoubleRange(axis);\n        if ((!axis.startFromZero) && (this.isColumn > 0)) {\n            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            axis.actualRange.max = axis.doubleRange.end + axis.actualRange.interval;\n            if ((axis.doubleRange.start - axis.actualRange.interval < 0 && axis.doubleRange.start > 0)) {\n                axis.actualRange.min = 0;\n            }\n            else {\n                axis.actualRange.min = axis.doubleRange.start - axis.actualRange.interval;\n            }\n        }\n        else {\n            axis.actualRange.interval = axis.interval || this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            axis.actualRange.min = axis.doubleRange.start;\n            axis.actualRange.max = axis.doubleRange.end;\n        }\n    };\n    /**\n     * Range for the axis.\n     *\n     * @private\n     */\n    Double.prototype.initializeDoubleRange = function (axis) {\n        //Axis Min\n        if (axis.minimum !== null) {\n            this.min = axis.minimum;\n        }\n        else if (this.min === null || this.min === Number.POSITIVE_INFINITY) {\n            this.min = 0;\n        }\n        // Axis Max\n        if (axis.maximum !== null) {\n            this.max = axis.maximum;\n        }\n        else if (this.max === null || this.max === Number.NEGATIVE_INFINITY) {\n            this.max = 5;\n        }\n        if (this.min === this.max) {\n            this.max = axis.valueType.indexOf('Category') > -1 ? this.max : this.min + 1;\n        }\n        axis.doubleRange = new DoubleRange(this.min, this.max);\n        axis.actualRange = {};\n    };\n    /**\n     * The function to calculate the range and labels for the axis.\n     *\n     * @returns {void}\n     * @private\n     */\n    Double.prototype.calculateRangeAndInterval = function (size, axis) {\n        this.calculateRange(axis);\n        this.getActualRange(axis, size);\n        this.applyRangePadding(axis, size);\n        this.calculateVisibleLabels(axis, this.chart);\n    };\n    /**\n     * Calculate Range for the axis.\n     *\n     * @private\n     */\n    Double.prototype.calculateRange = function (axis) {\n        /*! Generate axis range */\n        this.min = null;\n        this.max = null;\n        if (!setRange(axis)) {\n            for (var _i = 0, _a = axis.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (!series.visible) {\n                    continue;\n                }\n                this.paddingInterval = 0;\n                axis.maxPointLength = series.points.length;\n                if (((series.type.indexOf('Column') > -1 || series.type.indexOf('Histogram') > -1) && axis.orientation === 'Horizontal')\n                    || (series.type.indexOf('Bar') > -1 && axis.orientation === 'Vertical')) {\n                    if ((series.xAxis.valueType === 'Double' || series.xAxis.valueType === 'DateTime')\n                        && series.xAxis.rangePadding === 'Auto') {\n                        this.paddingInterval = getMinPointsDelta(series.xAxis, axis.series) * 0.5;\n                    }\n                }\n                //For xRange\n                if (axis.orientation === 'Horizontal') {\n                    if (this.chart.requireInvertedAxis) {\n                        this.yAxisRange(axis, series);\n                    }\n                    else {\n                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n                    }\n                }\n                // For yRange\n                if (axis.orientation === 'Vertical') {\n                    this.isColumn += (series.type === 'Column' || series.type === 'Bar' || series.drawType === 'Column') ? 1 : 0;\n                    if (this.chart.requireInvertedAxis) {\n                        this.findMinMax(series.xMin - this.paddingInterval, series.xMax + this.paddingInterval);\n                    }\n                    else {\n                        this.yAxisRange(axis, series);\n                    }\n                }\n            }\n        }\n    };\n    Double.prototype.yAxisRange = function (axis, series) {\n        if (series.dragSettings.enable && this.chart.dragY) {\n            if (this.chart.dragY >= axis.visibleRange.max) {\n                series.yMax = this.chart.dragY + axis.visibleRange.interval;\n            }\n            if (this.chart.dragY <= axis.visibleRange.min) {\n                series.yMin = this.chart.dragY - axis.visibleRange.interval;\n            }\n        }\n        this.findMinMax(series.yMin, series.yMax);\n    };\n    Double.prototype.findMinMax = function (min, max) {\n        if (this.min === null || this.min > min) {\n            this.min = min;\n        }\n        if (this.max === null || this.max < max) {\n            this.max = max;\n        }\n        if ((this.max === this.min) && this.max < 0 && this.min < 0) { // max == min\n            this.max = 0;\n        }\n    };\n    /**\n     * Apply padding for the range.\n     *\n     * @private\n     */\n    Double.prototype.applyRangePadding = function (axis, size) {\n        var start = axis.actualRange.min;\n        var end = axis.actualRange.max;\n        if (!setRange(axis)) {\n            var interval = axis.actualRange.interval;\n            var padding = axis.getRangePadding(this.chart);\n            if (padding === 'Additional' || padding === 'Round') {\n                this.findAdditional(axis, start, end, interval);\n            }\n            else if (padding === 'Normal') {\n                this.findNormal(axis, start, end, interval, size);\n            }\n            else {\n                this.updateActualRange(axis, start, end, interval);\n            }\n        }\n        axis.actualRange.delta = axis.actualRange.max - axis.actualRange.min;\n        this.calculateVisibleRange(size, axis);\n    };\n    Double.prototype.updateActualRange = function (axis, minimum, maximum, interval) {\n        axis.actualRange = {\n            min: axis.minimum != null ? axis.minimum : minimum,\n            max: axis.maximum != null ? axis.maximum : maximum,\n            interval: axis.interval != null ? axis.interval : interval,\n            delta: axis.actualRange.delta\n        };\n    };\n    Double.prototype.findAdditional = function (axis, start, end, interval) {\n        var minimum;\n        var maximum;\n        minimum = Math.floor(start / interval) * interval;\n        maximum = Math.ceil(end / interval) * interval;\n        if (axis.rangePadding === 'Additional') {\n            minimum -= interval;\n            maximum += interval;\n        }\n        this.updateActualRange(axis, minimum, maximum, interval);\n    };\n    Double.prototype.findNormal = function (axis, start, end, interval, size) {\n        var remaining;\n        var minimum;\n        var maximum;\n        var startValue = start;\n        if (start < 0) {\n            startValue = 0;\n            minimum = start + (start * 0.05);\n            remaining = interval + (minimum % interval);\n            if ((0.365 * interval) >= remaining) {\n                minimum -= interval;\n            }\n            if (minimum % interval < 0) {\n                minimum = (minimum - interval) - (minimum % interval);\n            }\n        }\n        else {\n            minimum = start < ((5.0 / 6.0) * end) ? 0 : (start - (end - start) * 0.5);\n            if (minimum % interval > 0) {\n                minimum -= (minimum % interval);\n            }\n        }\n        maximum = (end > 0) ? (end + (end - startValue) * 0.05) : (end - (end - startValue) * 0.05);\n        remaining = interval - (maximum % interval);\n        if ((0.365 * interval) >= remaining) {\n            maximum += interval;\n        }\n        if (maximum % interval > 0) {\n            maximum = (maximum + interval) - (maximum % interval);\n        }\n        axis.doubleRange = new DoubleRange(minimum, maximum);\n        if (minimum === 0) {\n            interval = this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size);\n            maximum = Math.ceil(maximum / interval) * interval;\n        }\n        this.updateActualRange(axis, minimum, maximum, interval);\n    };\n    /**\n     * Calculate visible range for axis.\n     *\n     * @private\n     */\n    Double.prototype.calculateVisibleRange = function (size, axis) {\n        axis.visibleRange = {\n            max: axis.actualRange.max, min: axis.actualRange.min,\n            delta: axis.actualRange.delta, interval: axis.actualRange.interval\n        };\n        if (this.chart.chartAreaType === 'Cartesian') {\n            var isLazyLoad = isNullOrUndefined(axis.zoomingScrollBar) ? false : axis.zoomingScrollBar.isLazyLoad;\n            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && !isLazyLoad) {\n                axis.calculateVisibleRangeOnZooming(this.chart);\n                axis.calculateAxisRange(size, this.chart);\n                axis.visibleRange.interval = (axis.enableAutoIntervalOnZooming && axis.valueType !== 'Category') ?\n                    this.calculateNumericNiceInterval(axis, axis.doubleRange.delta, size)\n                    : axis.visibleRange.interval;\n            }\n        }\n        axis.triggerRangeRender(this.chart, axis.visibleRange.min, axis.visibleRange.max, axis.visibleRange.interval);\n    };\n    /**\n     * Calculate label for the axis.\n     *\n     * @private\n     */\n    Double.prototype.calculateVisibleLabels = function (axis, chart) {\n        /*! Generate axis labels */\n        axis.visibleLabels = [];\n        var tempInterval = axis.visibleRange.min;\n        var labelStyle;\n        var controlName = chart.getModuleName();\n        var isPolarRadar = controlName === 'chart' && chart.chartAreaType === 'PolarRadar';\n        if (!isPolarRadar && (axis.zoomFactor < 1 || axis.zoomPosition > 0 || this.paddingInterval)) {\n            tempInterval = axis.visibleRange.min - (axis.visibleRange.min % axis.visibleRange.interval);\n        }\n        var format = this.getFormat(axis);\n        var isCustom = format.match('{value}') !== null;\n        var intervalDigits = 0;\n        var formatDigits = 0;\n        if (axis.labelFormat && axis.labelFormat.indexOf('n') > -1) {\n            formatDigits = parseInt(axis.labelFormat.substring(1, axis.labelFormat.length), 10);\n        }\n        axis.format = chart.intl.getNumberFormat({\n            format: isCustom ? '' : format,\n            useGrouping: chart.useGroupingSeparator\n        });\n        axis.startLabel = axis.format(axis.visibleRange.min);\n        axis.endLabel = axis.format(axis.visibleRange.max);\n        if (axis.visibleRange.interval && (axis.visibleRange.interval + '').indexOf('.') >= 0) {\n            intervalDigits = (axis.visibleRange.interval + '').split('.')[1].length;\n        }\n        var duplicateTempInterval;\n        for (; (tempInterval <= axis.visibleRange.max) && (duplicateTempInterval !== tempInterval); tempInterval += axis.visibleRange.interval) {\n            duplicateTempInterval = tempInterval;\n            labelStyle = (extend({}, getValue('properties', axis.labelStyle), null, true));\n            if (withIn(tempInterval, axis.visibleRange)) {\n                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n            }\n        }\n        if (tempInterval && (tempInterval + '').indexOf('.') >= 0 && (tempInterval + '').split('.')[1].length > 10) {\n            tempInterval = (tempInterval + '').split('.')[1].length > (formatDigits || intervalDigits) ?\n                +tempInterval.toFixed(formatDigits || intervalDigits) : tempInterval;\n            if (tempInterval <= axis.visibleRange.max) {\n                triggerLabelRender(chart, tempInterval, this.formatValue(axis, isCustom, format, tempInterval), labelStyle, axis);\n            }\n        }\n        if (axis.getMaxLabelWidth) {\n            axis.getMaxLabelWidth(this.chart);\n        }\n    };\n    /**\n     * Format of the axis label.\n     *\n     * @private\n     */\n    Double.prototype.getFormat = function (axis) {\n        if (axis.labelFormat) {\n            if (axis.labelFormat.indexOf('p') === 0 && axis.labelFormat.indexOf('{value}') === -1 && axis.isStack100) {\n                return '{value}%';\n            }\n            return axis.labelFormat;\n        }\n        return axis.isStack100 ? '{value}%' : '';\n    };\n    /**\n     * Formatted the axis label.\n     *\n     * @private\n     */\n    Double.prototype.formatValue = function (axis, isCustom, format, tempInterval) {\n        return isCustom ? format.replace('{value}', axis.format(tempInterval))\n            : axis.format(tempInterval);\n    };\n    return Double;\n}());\nexport { Double };\n"]},"metadata":{},"sourceType":"module"}