{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/* eslint-disable jsdoc/require-param */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\nimport { getPoint, appendClipElement, pathAnimation } from '../../common/utils/helper';\nimport { LineBase } from './line-base';\nimport { RectOption, getElement } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Base class for multi colored series\n */\n\nvar MultiColoredSeries = function (_super) {\n  __extends(MultiColoredSeries, _super);\n\n  function MultiColoredSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * To Generate the area path direction\n   *\n   * @param {number} xValue xValue\n   * @param {number} yValue yValue\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getPointLocation getPointLocation\n   * @param {ChartLocation} startPoint startPoint\n   * @param {string} startPath startPath\n   */\n\n\n  MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {\n    var direction = '';\n    var firstPoint;\n\n    if (startPoint === null) {\n      firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);\n      direction += startPath + ' ' + firstPoint.x + ' ' + firstPoint.y + ' ';\n    }\n\n    return direction;\n  };\n  /**\n   * To Generate the empty point direction\n   *\n   * @param {ChartLocation} firstPoint firstPoint\n   * @param {ChartLocation} secondPoint secondPoint\n   * @param {Series} series series\n   * @param {boolean} isInverted isInverted\n   * @param {Function} getPointLocation getPointLocation\n   */\n\n\n  MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {\n    var direction = '';\n    direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');\n    direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');\n    return direction;\n  };\n  /**\n   * To set point color\n   */\n\n\n  MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {\n    if (series.pointColorMapping === '') {\n      var segment = void 0;\n      var value = void 0;\n\n      for (var i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        value = isXSegment ? currentPoint.xValue : currentPoint.yValue;\n\n        if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) || !segment.value) {\n          currentPoint.interior = segment.color;\n          break;\n        }\n      }\n\n      if (currentPoint.interior == null) {\n        currentPoint.interior = series.interior;\n      }\n\n      return false;\n    } else {\n      if (previous) {\n        return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);\n      } else {\n        return false;\n      }\n    }\n  };\n\n  MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {\n    var _this = this;\n\n    var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;\n    var segments = [].concat(chartSegments);\n    return segments.sort(function (a, b) {\n      return _this.getAxisValue(a.value, axis, series.chart) - _this.getAxisValue(b.value, axis, series.chart);\n    });\n  };\n  /**\n   * Segment calculation performed here\n   *\n   * @param {Series} series series\n   * @param {PathOption[]} options options\n   * @param {ChartSegmentModel[]} segments chartSegments\n   */\n\n\n  MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments) {\n    var _this = this;\n\n    if (series.pointColorMapping !== '') {\n      options.map(function (option) {\n        _this.appendLinePath(option, series, '');\n      });\n      return null;\n    }\n\n    var isXSegment = series.segmentAxis === 'X';\n    var axis = isXSegment ? series.xAxis : series.yAxis;\n    var chart = series.chart;\n    var segment;\n    this.includeSegment(segments, axis, series, segments.length);\n    var length = segments.length;\n    var value;\n    var clipPath;\n    var attributeOptions;\n\n    var _loop_1 = function (index) {\n      segment = segments[index];\n      value = this_1.getAxisValue(segment.value, axis, series.chart);\n      clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart) : axis.visibleRange.min, value, series, index, isXSegment);\n\n      if (clipPath) {\n        options.map(function (option) {\n          attributeOptions = {\n            'clip-path': clipPath,\n            'stroke-dasharray': segment.dashArray,\n            'opacity': option.opacity,\n            'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : series.border.color,\n            'stroke-width': option['stroke-width'],\n            'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,\n            'id': option.id + '_Segment_' + index,\n            'd': option.d\n          };\n          pathAnimation(getElement(attributeOptions.id), attributeOptions.d, chart.redraw);\n          series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));\n        });\n      }\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < length; index++) {\n      _loop_1(index);\n    }\n  };\n\n  MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {\n    if (length <= 0) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n      return null;\n    }\n\n    if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {\n      segments.push({\n        value: axis.visibleRange.max,\n        color: series.interior\n      });\n    }\n  };\n  /**\n   * To create clip rect for segment axis\n   *\n   * @param {number} startValue startValue\n   * @param {number} endValue endValue\n   * @param {Series} series series\n   * @param {number} index index\n   * @param {boolean} isX isX\n   */\n\n\n  MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {\n    var isRequired = series.chart.requireInvertedAxis;\n    var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);\n    var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);\n    endPointLocation = isRequired ? [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;\n    var options;\n\n    if (endPointLocation.x - startPointLocation.x > 0 && endPointLocation.y - startPointLocation.y > 0) {\n      options = new RectOption(series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index, 'transparent', {\n        width: 1,\n        color: 'Gray'\n      }, 1, {\n        x: startPointLocation.x,\n        y: startPointLocation.y,\n        width: endPointLocation.x - startPointLocation.x,\n        height: endPointLocation.y - startPointLocation.y\n      });\n      series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));\n      return 'url(#' + series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index + ')';\n    }\n\n    return null;\n  };\n  /**\n   * To get exact value from segment value\n   *\n   * @param {Object} segmentValue segmentValue\n   * @param {Axis} axis axis\n   * @param {Chart} chart chart\n   */\n\n\n  MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {\n    if (segmentValue === null) {\n      segmentValue = axis.visibleRange.max;\n    }\n\n    if (axis.valueType === 'DateTime') {\n      var option = {\n        skeleton: 'full',\n        type: 'dateTime'\n      };\n      return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({\n        val: segmentValue\n      }).val))));\n    } else if (axis.valueType.indexOf('Category') > -1) {\n      var xValue = axis.valueType === 'DateTimeCategory' ? segmentValue.getTime().toString() : segmentValue;\n      return axis.labels.indexOf(xValue) < 0 ? +segmentValue : axis.labels.indexOf(xValue);\n    } else {\n      return +segmentValue;\n    }\n  };\n\n  return MultiColoredSeries;\n}(LineBase);\n\nexport { MultiColoredSeries };","map":{"version":3,"sources":["/workspace/Commb-olap-poc/commb-olap-js/node_modules/@syncfusion/ej2-charts/src/chart/series/multi-colored-base.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","getPoint","appendClipElement","pathAnimation","LineBase","RectOption","getElement","DataUtil","MultiColoredSeries","_super","apply","arguments","getAreaPathDirection","xValue","yValue","series","isInverted","getPointLocation","startPoint","startPath","direction","firstPoint","xAxis","yAxis","x","y","getAreaEmptyDirection","secondPoint","setPointColor","currentPoint","previous","isXSegment","segments","pointColorMapping","segment","value","i","length","getAxisValue","chart","interior","color","sortSegments","chartSegments","_this","axis","segmentAxis","concat","sort","a","applySegmentAxis","options","map","option","appendLinePath","includeSegment","clipPath","attributeOptions","_loop_1","index","this_1","createClipRect","visibleRange","min","dashArray","opacity","type","indexOf","border","id","redraw","seriesElement","appendChild","renderer","drawPath","push","max","startValue","endValue","isX","isRequired","requireInvertedAxis","startPointLocation","endPointLocation","element","width","height","segmentValue","valueType","skeleton","Date","parse","intl","getDateParser","getDateFormat","parseJson","val","getTime","toString","labels"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-returns */\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { getPoint, appendClipElement, pathAnimation } from '../../common/utils/helper';\nimport { LineBase } from './line-base';\nimport { RectOption, getElement } from '../../common/utils/helper';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * Base class for multi colored series\n */\nvar MultiColoredSeries = /** @class */ (function (_super) {\n    __extends(MultiColoredSeries, _super);\n    function MultiColoredSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * To Generate the area path direction\n     *\n     * @param {number} xValue xValue\n     * @param {number} yValue yValue\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getPointLocation getPointLocation\n     * @param {ChartLocation} startPoint startPoint\n     * @param {string} startPath startPath\n     */\n    MultiColoredSeries.prototype.getAreaPathDirection = function (xValue, yValue, series, isInverted, getPointLocation, startPoint, startPath) {\n        var direction = '';\n        var firstPoint;\n        if (startPoint === null) {\n            firstPoint = getPointLocation(xValue, yValue, series.xAxis, series.yAxis, isInverted, series);\n            direction += (startPath + ' ' + (firstPoint.x) + ' ' + (firstPoint.y) + ' ');\n        }\n        return direction;\n    };\n    /**\n     * To Generate the empty point direction\n     *\n     * @param {ChartLocation} firstPoint firstPoint\n     * @param {ChartLocation} secondPoint secondPoint\n     * @param {Series} series series\n     * @param {boolean} isInverted isInverted\n     * @param {Function} getPointLocation getPointLocation\n     */\n    MultiColoredSeries.prototype.getAreaEmptyDirection = function (firstPoint, secondPoint, series, isInverted, getPointLocation) {\n        var direction = '';\n        direction += this.getAreaPathDirection(firstPoint.x, firstPoint.y, series, isInverted, getPointLocation, null, 'L');\n        direction += this.getAreaPathDirection(secondPoint.x, secondPoint.y, series, isInverted, getPointLocation, null, 'L');\n        return direction;\n    };\n    /**\n     * To set point color\n     */\n    MultiColoredSeries.prototype.setPointColor = function (currentPoint, previous, series, isXSegment, segments) {\n        if (series.pointColorMapping === '') {\n            var segment = void 0;\n            var value = void 0;\n            for (var i = 0; i < segments.length; i++) {\n                segment = segments[i];\n                value = isXSegment ? currentPoint.xValue : currentPoint.yValue;\n                if (value <= this.getAxisValue(segment.value, isXSegment ? series.xAxis : series.yAxis, series.chart) || !segment.value) {\n                    currentPoint.interior = segment.color;\n                    break;\n                }\n            }\n            if (currentPoint.interior == null) {\n                currentPoint.interior = series.interior;\n            }\n            return false;\n        }\n        else {\n            if (previous) {\n                return series.setPointColor(currentPoint, series.interior) !== series.setPointColor(previous, series.interior);\n            }\n            else {\n                return false;\n            }\n        }\n    };\n    MultiColoredSeries.prototype.sortSegments = function (series, chartSegments) {\n        var _this = this;\n        var axis = series.segmentAxis === 'X' ? series.xAxis : series.yAxis;\n        var segments = [].concat(chartSegments);\n        return segments.sort(function (a, b) {\n            return _this.getAxisValue(a.value, axis, series.chart) - _this.getAxisValue(b.value, axis, series.chart);\n        });\n    };\n    /**\n     * Segment calculation performed here\n     *\n     * @param {Series} series series\n     * @param {PathOption[]} options options\n     * @param {ChartSegmentModel[]} segments chartSegments\n     */\n    MultiColoredSeries.prototype.applySegmentAxis = function (series, options, segments) {\n        var _this = this;\n        if (series.pointColorMapping !== '') {\n            options.map(function (option) {\n                _this.appendLinePath(option, series, '');\n            });\n            return null;\n        }\n        var isXSegment = series.segmentAxis === 'X';\n        var axis = isXSegment ? series.xAxis : series.yAxis;\n        var chart = series.chart;\n        var segment;\n        this.includeSegment(segments, axis, series, segments.length);\n        var length = segments.length;\n        var value;\n        var clipPath;\n        var attributeOptions;\n        var _loop_1 = function (index) {\n            segment = segments[index];\n            value = this_1.getAxisValue(segment.value, axis, series.chart);\n            clipPath = this_1.createClipRect(index ? this_1.getAxisValue(segments[index - 1].value, axis, series.chart)\n                : axis.visibleRange.min, value, series, index, isXSegment);\n            if (clipPath) {\n                options.map(function (option) {\n                    attributeOptions = {\n                        'clip-path': clipPath,\n                        'stroke-dasharray': segment.dashArray,\n                        'opacity': option.opacity,\n                        'stroke': series.type.indexOf('Line') > -1 ? segment.color || series.interior : series.border.color,\n                        'stroke-width': option['stroke-width'],\n                        'fill': series.type.indexOf('Line') > -1 ? 'none' : segment.color || series.interior,\n                        'id': option.id + '_Segment_' + index,\n                        'd': option.d\n                    };\n                    pathAnimation(getElement(attributeOptions.id), attributeOptions.d, chart.redraw);\n                    series.seriesElement.appendChild(chart.renderer.drawPath(attributeOptions));\n                });\n            }\n        };\n        var this_1 = this;\n        for (var index = 0; index < length; index++) {\n            _loop_1(index);\n        }\n    };\n    MultiColoredSeries.prototype.includeSegment = function (segments, axis, series, length) {\n        if (length <= 0) {\n            segments.push({ value: axis.visibleRange.max, color: series.interior });\n            return null;\n        }\n        if (this.getAxisValue(segments[length - 1].value, axis, series.chart) < axis.visibleRange.max) {\n            segments.push({ value: axis.visibleRange.max, color: series.interior });\n        }\n    };\n    /**\n     * To create clip rect for segment axis\n     *\n     * @param {number} startValue startValue\n     * @param {number} endValue endValue\n     * @param {Series} series series\n     * @param {number} index index\n     * @param {boolean} isX isX\n     */\n    MultiColoredSeries.prototype.createClipRect = function (startValue, endValue, series, index, isX) {\n        var isRequired = series.chart.requireInvertedAxis;\n        var startPointLocation = getPoint(isX ? startValue : series.xAxis.visibleRange.min, isX ? series.yAxis.visibleRange.max : endValue, series.xAxis, series.yAxis, isRequired);\n        var endPointLocation = getPoint(isX ? endValue : series.xAxis.visibleRange.max, isX ? series.yAxis.visibleRange.min : startValue, series.xAxis, series.yAxis, isRequired);\n        endPointLocation = isRequired ?\n            [startPointLocation, startPointLocation = endPointLocation][0] : endPointLocation;\n        var options;\n        if ((endPointLocation.x - startPointLocation.x > 0) && (endPointLocation.y - startPointLocation.y > 0)) {\n            options = new RectOption(series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\n                x: startPointLocation.x,\n                y: startPointLocation.y,\n                width: endPointLocation.x - startPointLocation.x,\n                height: endPointLocation.y - startPointLocation.y\n            });\n            series.seriesElement.appendChild(appendClipElement(series.chart.redraw, options, series.chart.renderer));\n            return 'url(#' + series.chart.element.id + '_ChartSegment' + series.index + 'ClipRect_' + index + ')';\n        }\n        return null;\n    };\n    /**\n     * To get exact value from segment value\n     *\n     * @param {Object} segmentValue segmentValue\n     * @param {Axis} axis axis\n     * @param {Chart} chart chart\n     */\n    MultiColoredSeries.prototype.getAxisValue = function (segmentValue, axis, chart) {\n        if (segmentValue === null) {\n            segmentValue = axis.visibleRange.max;\n        }\n        if (axis.valueType === 'DateTime') {\n            var option = { skeleton: 'full', type: 'dateTime' };\n            return Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({ val: segmentValue }).val))));\n        }\n        else if (axis.valueType.indexOf('Category') > -1) {\n            var xValue = axis.valueType === 'DateTimeCategory' ?\n                (segmentValue.getTime()).toString() :\n                segmentValue;\n            return (axis.labels.indexOf(xValue) < 0) ? +segmentValue : axis.labels.indexOf(xValue);\n        }\n        else {\n            return +segmentValue;\n        }\n    };\n    return MultiColoredSeries;\n}(LineBase));\nexport { MultiColoredSeries };\n"]},"metadata":{},"sourceType":"module"}